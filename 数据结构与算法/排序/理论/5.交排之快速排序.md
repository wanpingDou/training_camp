### 步骤

- 选取基准：从数据中选择一个数作为基准值（pivot），一般选择最左边。
- 分区操作：将数据中小于基准的全部放在pivot的左边位置，其余放在右边位置。该（分区）操作完成之后，原来的基准会在数据的中间某一位置。
- 递归下去，得到有序结果。



### 图解

[图片来源](https://xiaozhuanlan.com/topic/6439782051)

![快速排序](../img/快速排序.gif)



### 详情

> List = [5, 1, 3, 2, 4]，s = 0, t = 4

- 基准值tmp = 5，i=s，j=t
- j从右向左移动，即j=4，List[j]<=tmp，应该将4放前面5的位置，此时
  - List =  [4, 1, 3, 2, 4]
  - i = 0，j = 4
- j位置的值只要发生了交换，就要改变比较的方向去，即从i开始去比较。
- i从左向右移动，即i=0，List[i]<=tmp，继续向右移动i，此时，
  - i = 1，j = 4
- 只要i处的值比tmp小，i就一直向右移，最后i移动到j的位置，即i = j = 4。只要i与j相遇，即i==j，就将tmp插入这个相遇的位置。
- 一轮操作下来，List = [1, 3, 2, 4, 5]。分别对基准左右两个分区实时上述步骤，直至分区没有元素未知。
  - List = [1, 3, 2, 4, 5]，tmp=5左侧分区=[1, 3, 2, 4]，右侧为空。
  - 对分区[1, 3, 2, 4]采用上述步骤，得到tmp=1，数据为[1, 3, 2, 4]。整个List=[1, 3, 2, 4, 5]
  - 继续对[3, 2, 4]采用上述步骤，得到tmp=3，数据为[2, 3, 4]。整个List=[1, 2, 3, 4, 5]



### 复杂度

- 最好的情况，每次划分都将数据分成左右两个数量差不多的分区。这样递归树高度为$O(log_{2}n)$，每一层划分的时间为$O(n)$。
  - 时间复杂度：$O(nlog_{2}n)$
  - 空间复杂度：$O(log_{2}n)$
- 最坏的情况，每次划分都将数据分成一个分区。这样递归树的高度为$n$，需要$n-1$次划分。
  - 时间复杂度：$O(n^2)$
  - 空间复杂度：$O(n)$
- 平均情况下，接近最好。
  - 时间复杂度：$O(nlog_{2}n)$
  - 空间复杂度：$O(log_{2}n)$



### 算法

```python
# 一趟排序，目的是将左边的一个元素作为基准，将数据中小于基准全放基准的左边，
# 大于的部分放基准的右边，输出基准最终位置
## s为要排序的起始位置，t为要排序的结束位置
def partition(List, s, t):
    i, j = s, t
    tmp = List[i] # 基准
    while i<j:
        while j>i and List[j]>=tmp: # 从右向左扫描，直到右边的数比基准值小为止
            j -= 1                     ## 向左移动
        List[i] = List[j]              ## 将右边小于基准值的值排到前面i的位置去
        while i<j and List[i]<=tmp: # 从左向右扫描，直到左边的数比基准值大为止
            i += 1
        List[j] = List[i]
    List[i] = tmp
    return i

def QuickSort(List, s, t):
    # 递归部分
    if s>=t:
        return List
    else:
        i = partition(List, s, t)
        QuickSort(List, s, i-1)
        QuickSort(List, i+1, t)
    return List
```